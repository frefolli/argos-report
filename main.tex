\documentclass[a4paper,11pt,oneside, table]{article}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{imakeidx}
\usepackage{float}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{csquotes}
\usepackage{caption}
\captionsetup[table]{labelfont=it}
\usepackage{pifont}% http://ctan.org/pkg/pifont

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\usepackage{listings}
\usepackage{listings-cpp}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newtheorem{nota}{Nota}

\usepackage[italian]{babel}
\usepackage[
  backend=bibtex,
  style=numeric,
  sorting=ydnt
  ]{biblatex}
\addbibresource{quotes.bib}
\makeindex

\newcommand{\putimage}[4] {
	\begin{figure}[H]
	    \centering
	    \includegraphics[width={#4}\linewidth]{#1}
	    \caption{#2}\label{#3}
	\end{figure}
}

\newcommand{\putsubimage}[5] {
  \begin{minipage}{{#4}\linewidth}
	    \centering
      \includegraphics[width={#5}\linewidth]{#1}
	    \caption{#2}\label{#3}
	\end{minipage}
}

\newcommand{\putimagecouple}[2] {
  \begin{figure}[!htb]
      \centering
      #1
      \hspace{0.5cm}
      #2
  \end{figure}
}

\newcommand{\putimagequadruple}[4] {
  \begin{figure}[!htb]
      \centering
      #1
      \hspace{0.5cm}
      #2
      \linebreak
      #3
      \hspace{0.5cm}
      #4
  \end{figure}
}

\begin{document}
    \begin{titlepage}
        \noindent
        \begin{minipage}[t]{0.19\textwidth}
            \vspace{-4mm}{\includegraphics[scale=1.15]{logo_unimib.pdf}}
        \end{minipage}
        \begin{minipage}[t]{0.81\textwidth}
        {
                \setstretch{1.42}
                {\textsc{Università degli Studi di Milano - Bicocca}} \\
                \textbf{Scuola di Scienze} \\
                \textbf{Dipartimento di Informatica, Sistemistica e Comunicazione} \\
                \textbf{Corso di laurea magistrale in Informatica} \\
                \par
        }
        \end{minipage}
    	\vspace{40mm}
    	\begin{center}
            {\LARGE{
                    \setstretch{1.2}
                    \textbf{Relazione di Sistemi Complessi: Modelli e Simulazioni}
                    \par
            }}
        \end{center}
        
        \vspace{50mm}
        
        \vspace{15mm}

        \begin{flushright}
            {\large \textbf{Relazione di:}} \\
            \large{Preziosa Alessandro} \large{866142} \\
            \large{Refolli Francesco} \large{865955}
        \end{flushright}
        
        \vspace{40mm}
        \begin{center}
            {\large{\bf Anno Accademico 2023-2024}}
        \end{center}
        \restoregeometry
    \end{titlepage}

    \printindex
    \tableofcontents
    \renewcommand{\baselinestretch}{1.5}

\section{Introduzione}

La \textbf{Swarm Robotics} \`e un filone di ricerca della robotica che si occupa di costruire sistemi intelligenti formati da una moltitudine di droni/robot indipendenti eventualmente eterogenei (detto sciame) per raggiungere tramite algoritmi fortemente decentralizzati un obiettivo di interesse collettivo.
Le applicazioni della Swarm Robotics spaziano in campo civile e militare.
Solitamente la ricerca si concentra su scenari che prevedono il salvataggio di persone (Search and Rescure), la ricognizione di un ambiente, o l'impiego operativo in battaglia.
Gli alroritmi di Swarm Robotics possono anche avere ispirazione biologica\cite{mclurkin2005dynamic}.

Per la realizzazione di questi esperimenti sono stati costruiti diversi simulatori e qualche framework fisico per l'implementazione di sciami omogenei di robot.

L'obiettivo del progetto \`e simulare uno sciame di droni volanti il cui scopo \`e:
\begin{enumerate}
  \item dividersi in squadroni (partizioni dell'insieme di droni)
  \item decollare
  \item raggiungere gli obiettivi sparsi nell'ambiente, evitando collisioni con altri droni durante il volo.
\end{enumerate}


Per la simulazione ci siamo avvalsi di ARGoS \cite{Pinciroli:SI2012}, un simulatore programmabile Free and Open Source.

\section{ARGoS}

ARGoS \`e un simulatore di droni che permette di utilizzare diversi engine fisici a 2 o 3 dimensioni e aggiungere programmaticamente plugin per nuovi droni o nuovi contenuti.

In figura \ref{png:architecture} \`e riportato uno schema di funzionamento dell'engine di ARGoS da cui si possono trarre alcune osservazioni.
Per comandare un drone si deve implementare un \textbf{Controller}, il quale tramite \textbf{Attuatori} e \textbf{Sensori} pu\`o interagine con l'ambiente e con gli altri droni.
Solitamente questi componenti si appoggiano su un \textbf{Media} che costituisce il canale di comunicazione e storage delle informazioni.
Un altro valido strumento fornito al programmatore sono le \textbf{Loop Functions}, funzioni che vengono eseguite ad ogni tick, all'inizio o alla fine della simulazione per consentire interazioni custom con l'ambiente o di inizializzare la simulazione (per esempio istanziando oggetti o facendo controlli).
Una variante di queste sono le \textbf{User Functions}, che vengono solitamente impiegate per costruire effetti visivi in quanto permettono di interagire con lo stack grafico di ARGoS, per esempio disegnando label sulle entit\`a.
Si possono inoltre costruire delle \textbf{Loop Function}, funzioni solitamente utilizzate per interagire con la simulazione, e \textbf{User Functions}, funzioni che permettono di interagire con lo stack grafico di ARGoS.
Queste integrazioni vengono realizzate sotto forma di plugins che possono essere caricati dinamicamente tramite una configurazione XML di una simulazione, che permette anche di disporre automaticamente delle entit\`a nello spazio, di configurare i controller e abilitare le functions (non si possono utilizzare pi\`u di una Loop Function e di una User Function contemporaneamente).
L'Ambiente \`e definito in ARGoS in alcuni contesti \textit{Arena} ma \`e sostanzialmente un termine intercambiabile.

\putimage{images/architecture.png}{Architettura di ARGoS}{png:architecture}{0.99}

\section{Modello}

In figura \ref{png:simulation-model} si riporta lo schema logico dei componenti implementati per la simulazione.
Il \textit{cervello} del drone \`e suddiviso in due emisferi: un \textbf{TaskAllocator} che si occupa di decidere a quale target deve mirare (e quindi dove andare), un \textbf{TaskExecutor} che esegue questa volont\`a decidendo come raggiungere gli obiettivi del drone e come evitare intoppi (per esempio collisioni).
Entrambi questi componenti fanno uso di un \textbf{Random Number Generator}, del \textbf{Positioning Sensor} (che fornisce informazioni circa il proprio orientamento e il proprio posizionamento nell'ambiente) e un \textbf{Range And Bearing Sensor}.

Il \textit{Range and Bearing} rappresenta un antenna radio che permette di inviare e ricevere segnali. Questo viene fatto all'interno di ARGoS tramite un buffer di memoria dalla dimensione prefissata (\textit{RAB\_size}) all'inizio della simulazione.
Il sensore \textit{riceve} questi segnali da una distanza massima prefissata (\textit{RAB\_range}), e fornisce al controllore che li processa sia il contenuto del messaggio (\textit{Data}), sia la distanza da cui \`e stato percepito (\textit{Range}) e l'orientamento locale al sistema di riferimento del drone da cui proviene (\textit{HorizontalBearing e VerticalBearing}).
Per non complicare troppo il modello si \`e deciso di impostare il \textit{RAB\_range} ad un valore sufficiente per consentire a tutti i droni di ricevere tutti i segnali da ogni parte dell'Arena.
Per come \`e stato implementato in ARGoS non \`e possibile aggiornare lo stato dell'attuatore solo quando cambia uno stato locale ma \`e necessario scrivere un valore ogni volta. % (poteva essere implementato in modo pi\`u performante).
Dei dati che devono essere scritti sull'attuatore se ne occupa il Controller, il quale mantiene anche un \textbf{log} con alcune informazioni circa lo stato del drone e della simulazione dal punto di vista locale di esso.

Sia il TaskAllocator che il TaskExecutor possiedono uno stato che comanda il loro agire, in particolare in base alle esigenze della simulazione gli stati pozzo (\textit{Idle} e \textit{Arrived}) possono essere utilizzati per terminare la simulazione.
Di base essa termina solo quando tutti i droni \textit{ritengono} di aver finito il compito. Questo pu\`o avvenire in seguito al superamento del numero massimo di iterazioni (\textit{MAX\_ITERATION}), oppure quando il TaskExecutor rileva di essere rimasto \textit{fermo} (o \textit{quasi fermo} oltre una certa soglia di trascurabilit\`a), oppure nel caso in cui si necessita che il TaskAllocator termini dopo aver superato una fase di definizione del target da perseguire.
Quest'ultimo scenario (non sfruttato nelle nostre analisi) \`e utile nel caso si voglia valutare vuole valutare solo l'operato di diverse strategie di allocazione delle attivit\`a, (attuate queste si termina la simulazione prematuramente).


\paragraph{Codice Sorgente}

Il codice di questa implementazione \`e disponibile nel repository Github \textbf{\href{http://github.com/frefolli/argos-experiments}{frefolli/argos-experiments}} \cite{RF:AE}.
Per le analisi sui risultati sono stati scritti inoltre degli script Python per elaborare i log prodotti dai controller, diponibili nel repository \textbf{\href{http://github.com/frefolli/argos-visualizer}{frefolli/argos-visualizer}} \cite{RF:AV} insieme ad un ulteriore simulatore che permette di riprodurre (sebbene in modo pi\`u semplice) i log in forma di simulazione grafica.
Infine si \`e fatto uso di una versione modifica di ARGoS per correggere alcuni errori / implementare alcune feature lasciate parzialmente inutilizzabili dallo sviluppatore originale del simulatore. Questa versione modificata \`e disponibile nel repository \textbf{\href{http://github.com/frefolli/argos3}{frefolli/argos3}} \cite{RF:A3}.

\putimage{images/simulation-model.png}{Modello della Simulazione}{png:simulation-model}{0.99}

\section{Strategie implementate}

\subsection{TaskAllocator}

Un riassunto dell'implementazione del TaskAllocator \`e osservabile in figura \ref{png:task-allocator}.

\subsubsection{Scelta iniziale del Target}
Ogni drone all'inizio della simulazione sceglie un target iniziale, questo pu\`o essere fatto scegliendo un target a caso o prendendo il pi\`u vicino.
Il secondo approccio punta a minimizzare le disanze, ma il secondo (se la distribuzione \`e uniforme) tende a minimizzare la varianza delle grandezze degli squadroni.
Si ricorda che ogni squadrone \`e definito come i droni che agganciano un target.
Ogni drone, dopo una fase iniziale di scelta del target si pu\`o decidere di considerare l'allocazione terminata (per lui) senza ulteriori modifiche o di eseguire qualche iterazione di un algoritmo decentralizzato che tenti equilibrare le composizioni degli squadroni. 

\subsubsection{Fase di revisione della scelta del Target}
Durante le fasi di revisione, è possibile cambiare il proprio target solo se il proprio squadrone ha troppi droni assegnati rispetto a quanti ne dovrebbe avere.
Nel caso in cui per un drone sia possibile cambiare il prprio target, abbiamo creato due  strategie possibile che può adottare:
\begin{enumerate}
    \item cambio squadrone scegliendone uno a caso
    \item cambio squadrone scegliendo quello più bisognoso di droni.
\end{enumerate}

La rilocazione, possibile solo nel caso in qui in mio squadrone sia in eccesso di droni,  pu\`o avvenire certamente o avvenire con una certa probabilit\`a. Questa governa sia la probabilit\`a che la distribuzione di droni negli squadroni diventi pi\`u equa sia il numero di cambi che vengono effettuati (rendendo pi\`u instabile lo stato globale).

\putimage{images/task-allocator.png}{Comportamento del Task Allocator}{png:task-allocator}{0.99}

\subsection{TaskExecutor}

Un riassunto dell'implementazione del TaskExecutor \`e osservabile in figura \ref{png:task-executor}.

\subsubsection{Preparazione e Decollo}
Dopo una fase iniziale di attesa (si attendono MAX\_REVIEWING\_SESSIONS=20 tick in attesa che il TaskAllocator prenda le sue decisioni circa il target da perseguire) il drone passa in modalit\`a decollo. La fase di volo pu\`o avvenire tramite un iniziale decollo verticale e un successivo volo quasi orizzontale verso il target, oppure tramite un decollo diretto che utilizza il vettore di movimento diretto verso il target per prendere quota.
Il decollo \`e governato dall'esecutore tramite un audit dei droni nelle vicinanze per dare priorit\`a al decollo dei droni con ID pi\`u alto.

\subsubsection{Volo}
Un drone che ha raggiunto la quota di volo o che decolla direttamente deve eseguire un algoritmo che permette allo stesso di volare in direzione del target ma anche di evitare gli altri droni che ostacolano il percorso.
Questo \`e fatto tramite l'applicazione di forze repulsive tra droni, in particolare due potenziali che sono stati implementati sono: \textbf{GP} \`e un potenziale ispirato dalla gravit\`a, \textbf{LP} \`e derivato dal potenziale di Lennard Jones.

\subsubsection{Criterio di Arresto}
Come detto in precedenza, l'esecutore misura la differenza tra la posizione rilevata correntemente e quella rilevata nel tick precedente, la utilizza per stabilire la velocit\`a con cui si \`e mosso il drone in precedenza e in base alla magnitudine di essa decide se \`e fermo o quasi fermo.
In particolare noi consideriamo fermo un drone la cui velocit\`a istantanea \`e inferiore a $10e-4$.

\subsubsection{Rumore Desiderato}
Infine abbiamo cosiderato la possibilit\`a di introdurre del rumore nel vettore della velocit\`a desiderata dall'esecutore per creare dell'instabilit\`a sufficiente a smuovere alcune situazioni di stallo nel volo dei droni che si potrebbero creare (ad esempio quando due droni vogliono andare nella stessa direzione ma nel verso opposto).
Per realizzare ci\`o \`e fondamentale valutare l'impatto del coefficiente di rumore per evitare che l'instabilit\`a sia tale da non permettere alla simulazione di convergere.

\putimage{images/task-executor.png}{Comportamento del Task Executor}{png:task-executor}{0.99}

\section{Esperimenti e Risultati}

Sono state condotte delle simulazioni con ARGoS variando in ciascuna la strategia implementata ma mantenendo lo stesso Seed che inizializza il Pseudo Random Number Generator per confrontare direttamente approcci differenti nello stesso scenario.
Si \`e scelto di testare singolarmente il TaskAllocator e il TaskExecutor per ridurre lo spazio delle soluzioni possibili.
Ogni esecuzione di simulazione genera dei file di Log che vengono scritti dal Controller di ciascun drone e che ci ha permesso di produrre alcune metriche utili nell'analisi.

\subsection{TaskAllocator}

\subsection{TaskExecutor}

\section{Conclusione}

\printbibliography[title={Bibliografia}]

\end{document}
