\documentclass[a4paper,11pt,oneside, table]{article}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{imakeidx}
\usepackage{float}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{csquotes}
\usepackage{caption}
\captionsetup[table]{labelfont=it}
\usepackage{pifont}% http://ctan.org/pkg/pifont

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\usepackage{listings}
\usepackage{listings-cpp}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newtheorem{nota}{Nota}

\usepackage[italian]{babel}
\usepackage[
  backend=bibtex,
  style=numeric,
  sorting=ydnt
  ]{biblatex}
\addbibresource{quotes.bib}
\makeindex

\newcommand{\putimage}[4] {
	\begin{figure}[H]
	    \centering
	    \includegraphics[width={#4}\linewidth]{#1}
	    \caption{#2}\label{#3}
	\end{figure}
}

\newcommand{\putsubimage}[5] {
  \begin{minipage}{{#4}\linewidth}
	    \centering
      \includegraphics[width={#5}\linewidth]{#1}
	    \caption{#2}\label{#3}
	\end{minipage}
}

\newcommand{\putimagecouple}[2] {
  \begin{figure}[!htb]
      \centering
      #1
      \hspace{0.5cm}
      #2
  \end{figure}
}

\newcommand{\putimagequadruple}[4] {
  \begin{figure}[!htb]
      \centering
      #1
      \hspace{0.5cm}
      #2
      \linebreak
      #3
      \hspace{0.5cm}
      #4
  \end{figure}
}

\begin{document}
    \begin{titlepage}
        \noindent
        \begin{minipage}[t]{0.19\textwidth}
            \vspace{-4mm}{\includegraphics[scale=1.15]{logo_unimib.pdf}}
        \end{minipage}
        \begin{minipage}[t]{0.81\textwidth}
        {
                \setstretch{1.42}
                {\textsc{Universit√† degli Studi di Milano - Bicocca}} \\
                \textbf{Scuola di Scienze} \\
                \textbf{Dipartimento di Informatica, Sistemistica e Comunicazione} \\
                \textbf{Corso di laurea magistrale in Informatica} \\
                \par
        }
        \end{minipage}
    	\vspace{40mm}
    	\begin{center}
            {\LARGE{
                    \setstretch{1.2}
                    \textbf{Relazione di Sistemi Complessi: Modelli e Simulazioni}
                    \par
            }}
        \end{center}
        
        \vspace{50mm}
        
        \vspace{15mm}

        \begin{flushright}
            {\large \textbf{Relazione di:}} \\
            \large{Preziosa Alessandro} \large{866142} \\
            \large{Refolli Francesco} \large{865955}
        \end{flushright}
        
        \vspace{40mm}
        \begin{center}
            {\large{\bf Anno Accademico 2023-2024}}
        \end{center}
        \restoregeometry
    \end{titlepage}

    \printindex
    \tableofcontents
    \renewcommand{\baselinestretch}{1.5}

\section{Introduzione}

La \textbf{Swarm Robotics} \`e un filone di ricerca della robotica che si occupa di costruire sistemi intelligenti formati da una moltitudine di droni/robot indipendenti (eventualmente eterogenei) per raggiungere tramite algoritmi fortemente decentralizzati un obiettivo di collettivo interesse (rispetto allo sciame).
Le applicazioni della Swarm Robotics spaziano in campo civile e militare.
Solitamente la ricerca si concentra su scenari che prevedono il salvataggio, la ricognizione o una battaglia.
Tuttavia essendo un concetto molto astratto vengono anche applicati alla costruzione di algoritmi di ottimizzazione.

Per la realizzazione di questi esperimenti sono stati costruiti diversi simulatori e qualche framework fisico per l'implementazione di sciami di robot dal basso costo.
L'obiettivo del progetto \`e simulare uno sciame il cui scopo \`e dividersi in squadroni, decollare ed approcciare degli obiettivi sparsi nell'ambiente.
Per la simulazione ci siamo avvalsi di ARGoS \cite{Pinciroli:SI2012}, un simulatore programmabile Free and Open Source.

\section{ARGoS}

ARGoS \`e un simulatore di droni che permette di utilizzare diversi engine fisici a 2 o 3 dimensioni e aggiungere programmaticamente plugin per nuovi droni o nuovi contenuti.

In figura \ref{png:architecture} \`e riportato uno schema di funzionamento dell'engine di ARGoS da cui si possono trarre alcune osservazioni.
Per comandare un drone si deve implementare un \textbf{Controller}, il quale tramite \textbf{Attuatori} e \textbf{Sensori} pu\`o interagine con l'ambiente e con gli altri droni.
Solitamente questi componenti si appoggiano su un \textbf{Media} che costituisce il canale di comunicazione e storage delle informazioni.
Un altro valido strumento fornito al programmatore sono le \textbf{Loop Functions}, funzioni che vengono eseguite ad ogni tick, all'inizio o alla fine della simulazione per consentire interazioni custom con l'ambiente o di inizializzare la simulazione (per esempio istanziando oggetti o facendo controlli).
Una variante di queste sono le \textbf{User Functions}, che vengono solitamente impiegate per costruire effetti visivi in quanto permettono di interagire con lo stack grafico di ARGoS, per esempio disegnando label sulle entit\`a.
Si possono inoltre costruire delle \textbf{Loop Function}, funzioni solitamente utilizzate per interagire con la simulazione, e \textbf{User Functions}, funzioni che permettono di interagire con lo stack grafico di ARGoS.
Queste integrazioni vengono realizzate sotto forma di plugins che possono essere caricati dinamicamente tramite una configurazione XML di una simulazione, che permette anche di disporre automaticamente delle entit\`a nello spazio, di configurare i controller e abilitare le functions (non si possono utilizzare pi\`u di una Loop Function e di una User Function contemporaneamente).
L'Ambiente \`e definito in ARGoS in alcuni contesti \textit{Arena} ma \`e sostanzialmente un termine intercambiabile.

\putimage{images/architecture.png}{Architettura di ARGoS}{png:architecture}{0.99}

\section{Modello}

In figura \ref{png:simulation-model} si riporta lo schema logico dei componenti implementati per la simulazione.
Il \textit{cervello} del drone \`e suddiviso in due emisferi: un \textbf{TaskAllocator} che si occupa di decidere a quale squadrone deve mirare e quindi dove andare, un \textbf{TaskExecutor} che esegue questa volont\`a decidendo come raggiungere gli obiettivi del drone e come evitare intoppi (per esempio collisioni).
Entrambi questi componenti fanno uso di un \textbf{Random Number Generator}, del \textbf{Positioning Sensor} (che fornisce informazioni circa il proprio orientamento e il proprio posizionamento nell'ambiente) e un \textbf{Range And Bearing Sensor}.

Il \textit{Range and Bearing} \`e un mezzo simile ad una antenna radio che permette di inviare e ricevere segnali. Questo viene fatto all'interno di ARGoS tramite un buffer di memoria dalla dimensione prefissata (\textit{RAB\_size}) all'inizio della simulazione.
Il sensore \textit{riceve} questi segnali da una distanza massima prefissata (\textit{RAB\_range}), e fornisce al controllore che li processia sia il contenuto del messaggio (\textit{Data}), sia la distanza da cui \`e stato percepito (\textit{Range}) e l'orientamento locale al sistema di riferimento del drone da cui proviene (\textit{HorizontalBearing e VerticalBearing}).
Per non complicare troppo il modello si \`e deciso di impostare il \textit{RAB\_range} ad un valore sufficiente per consentire a tutti i droni di ricevere tutti i segnali da ogni parte dell'Arena.
Per come \`e stato implementato in ARGoS non \`e possibile aggiornare lo stato dell'attuatore solo quando cambia uno stato locale ma \`e necessario scrivere un valore ogni volta. % (poteva essere implementato in modo pi\`u performante).
Dei dati che devono essere scritti sull'attuatore se ne occupa il Controller, il quale mantiene anche un \textbf{log} con alcune informazioni circa lo stato del drone e della simulazione dal punto di vista locale di esso.

Sia il TaskAllocator che il TaskExecutor possiedono uno stato che comanda la loro operazione, in particolare in base alle esigenze della simulazione gli stati pozzo (\textit{Idle} e \textit{Arrived}) possono essere utilizzati per terminare la simulazione.
Di base essa termina solo quando tutti i droni \textit{ritengono} di aver finito il compito. Questo pu\`o avvenire in segui al superamento del numero massimo di iterazioni (\textit{MAX\_ITERATION}), oppure quando il TaskExecutor rileva di essere rimasto \textit{fermo} (o \textit{quasi fermo} oltre una certa soglia di trascurabilit\`a), oppure nel caso in cui si necessita che il TaskAllocator termini dopo aver superato una fase di definizione del target da perseguire.
Quest'ultimo scenario \`e utile quando si vuole valutare l'operato di diverse strategie di allocazione delle attivit\`a.

\paragraph{Codice Sorgente}

Il codice di questa implementazione \`e disponibile nel repository Github \textbf{\href{http://github.com/frefolli/argos-experiments}{frefolli/argos-experiments}} \cite{RF:AE}.
Per le analisi sui risultati sono stati scritti inoltre degli script Python per elaborare i log prodotti dai controller, diponibili nel repository \textbf{\href{http://github.com/frefolli/argos-visualizer}{frefolli/argos-visualizer}} \cite{RF:AV} insieme ad un ulteriore simulatore che permette di riprodurre (sebbene in modo pi\`u semplice) i log in forma di simulazione grafica.
Infine si \`e fatto uso di una versione modifica di ARGoS per correggere alcuni errori / implementare alcune feature lasciate parzialmente inutilizzabili dallo sviluppatore originale del simulatore. Questa versione modificata \`e disponibile nel repository \textbf{\href{http://github.com/frefolli/argos3}{frefolli/argos3}} \cite{RF:A3}.

\putimage{images/simulation-model.png}{Modello della Simulazione}{png:simulation-model}{0.99}

\section{Strategie implementate}

\subsection{TaskAllocator}

\subsection{TaskExecutor}

\section{Risultati}

\section{Conclusione}

\printbibliography[title={Bibliografia}]

\end{document}
